this is the codebase: 
 
```MediaControls.kt    
 
package com.example.hello_world




@Composable
fun MediaControls(
    onPlayPause: () -> Unit, // Function to call when the play/pause button is pressed
    onSeekForward: () -> Unit, // Function to call when the seek forward button is pressed
    onSeekBackward: () -> Unit // Function to call when the seek backward button is pressed
) {
    var isPlaying by remember { mutableStateOf(false) } // Add the state variable isPlaying

    Row {
        IconButton(onClick = {
            onPlayPause() // Call the onPlayPause function
            isPlaying = !isPlaying // Toggle the isPlaying state
        }) {
            if (isPlaying) {
                Icon(Icons.Filled.AccountBox, contentDescription = "Pause") // Show the pause icon
            } else {
                Icon(Icons.Filled.PlayArrow, contentDescription = "Play") // Show the play icon
            }
        }
        IconButton(onClick = onSeekBackward) { // Create a button for the seek backward button
            Icon(Icons.Filled.KeyboardArrowLeft, contentDescription = "Seek Backward") // Show the seek backward icon
        }
        IconButton(onClick = onSeekForward) { // Create a button for the seek forward button
            Icon(Icons.Filled.KeyboardArrowRight, contentDescription = "Seek Forward") // Show the seek forward icon
        }

    }
 
``` 
 
 
```MessageCard.kt    
 
package com.example.hello_world



@Composable
@ExperimentalMaterial3Api
@OptIn(ExperimentalMaterialApi::class)
fun MessageCard( // Composable for the message card
    message: ConversationMessage, // The message to show
    onPlayAudio: (String) -> Unit, // Function to call when the play audio button is pressed
    onCardClicked: () -> Unit, // this is what it does if you click on the card
    mediaPlaybackManager: MediaPlaybackManager,
    context: Context,
    onDeleteClicked: () -> Unit,
    onEditClicked: (ConversationMessage, String) -> Unit
) {
    val isEditing = remember { mutableStateOf(false) }
    val editedMessage = remember { mutableStateOf(message.message) }
//    Log.d("MessageCard", "Message: $message")
    Card( // Create a card for the message
        modifier = Modifier // Set the modifier for the card
            .clickable { onCardClicked() } //the card is clickable!
            .padding(8.dp) // Add padding to the card
            .fillMaxWidth() // Make the card fill the width of the screen
    ) {
        Column( // Create a column for the message
            modifier = Modifier // Set the modifier for the column
                .padding(16.dp) // Add padding to the column
        ) {
            Text(text = message.sender, fontWeight = FontWeight.Bold) // Show the sender of the message
            Spacer(modifier = Modifier.height(4.dp)) // Add a spacer to add some space between the sender and the message
            if (isEditing.value) {
                TextField(
                    value = editedMessage.value,
                    onValueChange = { editedMessage.value = it },
                    modifier = Modifier.fillMaxWidth()
                )
            } else {
                SelectionContainer {
                    Text(text = message.message)
                }
            }
            if (isEditing.value) { // add this line
                Row { // add this line
                    Button( // add this line
                        onClick = { // add this line
                            onEditClicked(message, editedMessage.value) // add this line
                            isEditing.value = false // add this line
                        } // add this line
                    ) { // add this line
                        Text("Save") // add this line
                    } // add this line
                    Button( // add this line
                        onClick = { // add this line
                            isEditing.value = false // add this line
                        } // add this line
                    ) { // add this line
                        Text("Cancel") // add this line
                    } // add this line
                } // add this line
            }
            Spacer(modifier = Modifier.height(8.dp)) // Add a spacer to add some space between the message and the media controls
            Row { // Add this row
                IconButton(onClick = { isEditing.value = !isEditing.value }) {
                    Icon(Icons.Filled.Create, contentDescription = "Edit message")
                }
                IconButton(onClick = onDeleteClicked) {
                    Icon(Icons.Filled.Close, contentDescription = "Delete message")
                }
            }
            MediaControls( // Show the media controls
                onPlayPause = { // When the play/pause button is pressed
                    if (mediaPlaybackManager.isPlaying()) {
                        Log.d("MessageCard", "Pausing audio from file: ${message.audioFilePath.value}")
                        mediaPlaybackManager.pause()
                    } else {
                        Log.d("MessageCard", "Resuming audio from file: ${message.audioFilePath.value}")
                        mediaPlaybackManager.playAudio(message.audioFilePath.value, context)
                    }
                },
                onSeekForward = { mediaPlaybackManager.seekForward() }, // Pass the seekForward callback
                onSeekBackward = { mediaPlaybackManager.seekBackward() } // Pass the seekBackward callback
            )
        }
    }
 
``` 
 
 
```EditSettingsScreen.kt    
 


@Composable
fun EditSettingsScreen(settingsViewModel: SettingsViewModel, onSettingsSaved: () -> Unit, onCancel: () -> Unit) {
    val editedProfile = settingsViewModel.editedConfigPack.value // Access the value property here

    Column(modifier = Modifier.fillMaxSize()) {
        Text("Edit Settings", modifier = Modifier.padding(16.dp))

        OutlinedTextField(
            value = editedProfile.name, // Access the name property from the value
            onValueChange = { newValue -> settingsViewModel.updateEditedProfileName(newValue) }, // Use newValue instead of it
            label = { Text("Profile Name") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )

        OutlinedTextField(
            value = editedProfile.systemMessage.takeIf { it.isNotEmpty() } ?: "I am an AI assistant.",
            onValueChange = { newValue -> settingsViewModel.updateEditedProfileSystemMessage(newValue) },
            label = { Text("System Message") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )
        Text("Max Length (20 to 2000)", modifier = Modifier.padding(start = 16.dp, top = 8.dp))
        Slider(
            value = editedProfile.maxLength.toFloat(),
            onValueChange = { newValue -> settingsViewModel.updateEditedProfileMaxLength(newValue.toInt()) },
            valueRange = 20f..2000f,
            steps = 5,
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )
        Text("Temperature", modifier = Modifier.padding(start = 16.dp, top = 8.dp))
        Slider(
            value = editedProfile.temperature.toFloat(),
            onValueChange = { newValue -> settingsViewModel.updateEditedProfileTemperature(newValue.toDouble()) },
            valueRange = 0f..1f,
            steps = 10,
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )
        Text("Frequency Penalty", modifier = Modifier.padding(start = 16.dp, top = 8.dp))
        Slider(
            value = editedProfile.frequencyPenalty.toFloat(),
            onValueChange = { newValue -> settingsViewModel.updateEditedProfileFrequencyPenalty(newValue.toDouble()) },
            valueRange = 0f..1f,
            steps = 10,
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )
        Text("Presence Penalty", modifier = Modifier.padding(start = 16.dp, top = 8.dp))
        Slider(
            value = editedProfile.presencePenalty.toFloat(),
            onValueChange = { newValue -> settingsViewModel.updateEditedProfilePresencePenalty(newValue.toDouble()) },
            valueRange = 0f..1f,
            steps = 10,
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        )
        Text("Model", modifier = Modifier.padding(start = 16.dp, top = 8.dp))
        Row(modifier = Modifier.padding(horizontal = 16.dp)) {
            val models = listOf("gpt-3.5-turbo", "gpt-4")
            models.forEach { model ->
                Row(
                    Modifier
                        .padding(end = 16.dp)
                        .selectable(
                            selected = (model == editedProfile.model),
                            onClick = { settingsViewModel.updateEditedProfileModel(model) }
                        )
                ) {
                    RadioButton(
                        selected = (model == editedProfile.model),
                        onClick = { settingsViewModel.updateEditedProfileModel(model) }
                    )
                    Text(
                        text = model,
                        modifier = Modifier.padding(start = 8.dp)
                    )
                }
            }
        }


        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            Button(onClick = {
                settingsViewModel.saveEditedProfile()
                onSettingsSaved()
                Log.d("EditSettingsScreen", "Save button clicked")
            }) {
                Text("Save")
            }

            Button(onClick = {
                onCancel()
                Log.d("EditSettingsScreen", "Cancel button clicked")
            }) {
                Text("Cancel")
            }
        }
    }
    //display the properties of the profile
    
 
``` 
 
 
```HomeScreen.kt    
 
package com.example.hello_world


@Composable
fun HomeScreen(
    onSessionsClicked: () -> Unit,
    onConfigPacksClicked: () -> Unit
) {
    Column {
        Button(onClick = onSessionsClicked) {
            Text("Sessions")
        }
        Button(onClick = onConfigPacksClicked) {
            Text("Config Packs")
        }
    }
 
``` 
 
 
```HomeViewModel.kt    
 
package com.example.hello_world.ui.home.viewmodel


class HomeViewModel : ViewModel() {
    // Any future logic related to the home screen can be added here
 
``` 
 
 
```SavedConversationsScreen.kt    
 
package com.example.hello_world

//import androidx.compose.material.CardElevation

@Composable
@ExperimentalMaterial3Api
@OptIn(ExperimentalMaterialApi::class)
fun SavedConversationsScreen(
    viewModel: SavedConversationsViewModel,
    onConversationSelected: (UUID) -> Unit,
    onBack: () -> Unit,
    onNewConversationClicked: () -> Unit
) {
    val savedConversations by viewModel.savedConversations.collectAsState(initial = emptyList<Conversation>())

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Saved Conversations") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = onNewConversationClicked) {
                Icon(Icons.Default.Add, contentDescription = "New Conversation")
            }
        }
    ) {
        if (savedConversations.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text("No saved conversations")
            }
        } else {
            LazyColumn(modifier = Modifier.padding(8.dp)) {
                items(savedConversations.size) { index ->
                    val conversation = savedConversations[index]
                    ConversationCard(
                        conversation = conversation,
                        onClick = {
                            Log.d("SavedConversationsScreen", "Selected conversation ID: ${conversation.id}")
                            onConversationSelected(conversation.id)
                        },
                        onDeleteClicked = { viewModel.deleteConversation(conversation.id) }
                    )
                }
            }
        }
    }
}

@Composable
fun CardElevation(
    modifier: Modifier = Modifier,
    elevation: Dp,
    content: @Composable ColumnScope.() -> Unit
) {
    Card(
        modifier = modifier.graphicsLayer(
            shadowElevation = elevation.value,
            shape = RoundedCornerShape(4.dp),
            clip = true
        ),
        content = content
    )
}

@Composable
fun ConversationCard(
    conversation: Conversation,
    onClick: () -> Unit,
    onDeleteClicked: () -> Unit
) {
    CardElevation(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .clickable { onClick() },
        elevation = 4.dp
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(conversation.title)
            Text("Date started: ${formatDate(conversation.dateStarted)}")
            Text("Date last saved: ${formatDate(conversation.dateLastSaved)}")
            Text("Message count: ${conversation.messageCount}")
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                IconButton(onClick = onDeleteClicked) {
                    Icon(Icons.Default.Delete, contentDescription = "Delete")
                }
            }
        }
    }
}

fun formatDate(timestamp: Long): String {
    val dateFormat = SimpleDateFormat("MMM dd, yyyy, HH:mm", Locale.getDefault())
    return dateFormat.format(Date(timestamp))
 
``` 
 
 
```SavedConversationsViewModel.kt    
 
package com.example.hello_world.ui.saved_conversations.viewmodel


class SavedConversationsViewModel(
    private val conversationRepository: IConversationRepository
) : ViewModel() {
    private val _savedConversations = MutableStateFlow<List<Conversation>>(emptyList())
    val savedConversations: StateFlow<List<Conversation>> = _savedConversations
    private val conversationsManager = ConversationsManager(conversationRepository)

    init {
        viewModelScope.launch {
            _savedConversations.value = loadSavedConversations()
        }
    }

    suspend fun createNewConversation(): UUID {
        val newConversation = Conversation(configPack = ConfigPack.defaultConfigPack)
        conversationsManager.saveConversation(newConversation) // Modify this line
        return newConversation.id
    }

    private suspend fun loadSavedConversations(): List<Conversation> {
        // Replace the TODO with the actual implementation
        return conversationRepository.loadAllConversations()
    }

    // Implement methods for deleting saved conversations
    fun deleteConversation(conversationId: UUID) {
        viewModelScope.launch {
            conversationRepository.deleteConversation(conversationId)
            _savedConversations.value = loadSavedConversations()
        }
    }
 
``` 
 
 
```SessionScreen.kt    
 
package com.example.hello_world



@Composable
@ExperimentalMaterial3Api
@OptIn(ExperimentalMaterialApi::class)
fun SessionScreen(
    sessionViewModel: SessionViewModel,
    settingsViewModel: SettingsViewModel,
    onSettingsClicked: () -> Unit,
    textToSpeechServiceState: MutableState<TextToSpeechService>,
    mediaPlaybackManager: MediaPlaybackManager,
    navController: NavController
) {
    LaunchedEffect(sessionViewModel) {
        sessionViewModel.conversationId?.let {
            sessionViewModel.loadConversation(it)
        }
    }
    val context = LocalContext.current // Get the current context
    val scrollToBottomClicked = remember { mutableStateOf(false) } // Create a mutable state for the scroll to bottom button
    val conversationTextState = remember { mutableStateOf("") }
    BoxWithConstraints( // Create a box with constraints to get the maximum height of the screen
        modifier = Modifier // Set the modifier for the box
            .fillMaxSize() // Make the box fill the entire screen
            .padding(16.dp) // Add padding to the box
    ) {

        val lazyListState = rememberLazyListState() // Create a lazy list state for the lazy column

        val messages = sessionViewModel.conversationMessages // Get the conversation messages
        Log.d("SessionScreen", "Number of messages in session screen: ${messages.size}")
        LaunchedEffect(Unit) {
            if (scrollToBottomClicked.value) {
                val targetIndex = messages.size - 1
                try {
                    lazyListState.animateScrollToItem(targetIndex)
                } catch (e: Exception) {
                    Log.e("SessionScreen", "Error while animating scroll to item", e)
                }
                scrollToBottomClicked.value = false
            }
            Log.d("SessionScreen", "Current messages in session screen: $messages")
        }
        val maxHeight = constraints.maxHeight // Get the maximum height of the screen
        Column(modifier = Modifier.fillMaxSize()) { // Create a column for the main screen
            LazyColumn( // Create a lazy column for the messages
                modifier = Modifier // Set the modifier for the lazy column
                    .weight(1f) // Make the lazy column fill the entire screen
                    .height(((maxHeight.dp - 64.dp).coerceAtLeast(0.dp))) // Set the height of the lazy column to the maximum height of the screen minus the height of the buttons
            ) {
                items(messages) { message -> // For each message in the conversation messages
                    MessageCard(
                        message = message,
                        onPlayAudio = { audioFilePath ->
                            sessionViewModel.mediaPlaybackManager.playAudio(audioFilePath, context)
                        },
                        onCardClicked = {
                            Log.d("SessionScreen", "Card with index ${messages.indexOf(message)} clicked")
                        },
                        mediaPlaybackManager = mediaPlaybackManager,
                        context = context,
                        onDeleteClicked = {
                            // Log the delete action and message index
                            Log.d("SessionScreen", "Delete button clicked for message at index ${messages.indexOf(message)}")
                            // Call the deleteMessage method from MainViewModel
                            sessionViewModel.deleteMessage(messages.indexOf(message))
                        },
                        onEditClicked = { message, editedMessage ->
                            val index = messages.indexOf(message)
                            sessionViewModel.updateMessage(index, message.copy(message = editedMessage))
                            // Log the edit action and message index
                            Log.d("SessionScreen", "Edit button clicked for message at index ${messages.indexOf(message)}")
                        }
                    )
                }
            }
            Spacer(modifier = Modifier.height(16.dp)) // Add a spacer to add some space between the messages and the buttons
            Text( // Show the listening status
                text = if (sessionViewModel.isListening) "Listening..." else "Not Listening",  // Show "Listening..." if the app is listening and "Not Listening" if the app is not listening
                modifier = Modifier.align(Alignment.CenterHorizontally) // Align the text to the center horizontally
            )
            Spacer(modifier = Modifier.height(16.dp)) // Add a spacer to add some space between the listening status and the buttons
            Button(
                onClick = { // When the start listening button is pressed
                    if (textToSpeechServiceState.value is AndroidTextToSpeechService) { // If the text to speech service is the Android text to speech service
                        textToSpeechServiceState.value = ElevenLabsTextToSpeechService("82b94d982c1018cb379c0acb629d473c", "TxGEqnHWrfWFTfGW9XjX", context, mediaPlaybackManager) { sessionViewModel.startListening() }  // Set the text to speech service to the Eleven Labs text to speech service
                    } else { // If the text to speech service is not the Android text to speech service
                        textToSpeechServiceState.value = AndroidTextToSpeechService(context, mediaPlaybackManager) { sessionViewModel.startListening() } // Set the text to speech service to the Android text to speech service
                    }
                },
                modifier = Modifier.align(Alignment.CenterHorizontally) // Align the button to the center horizontally
            ) {
                Text(if (textToSpeechServiceState.value is AndroidTextToSpeechService) "Use Eleven Labs TTS" else "Use Google TTS") // Show "Use Eleven Labs TTS" if the text to speech service is the Android text to speech service and "Use Google TTS" if the text to speech service is not the Android text to speech service
            }
            Button( // Create a button for the start listening button
                onClick = { // When the start listening button is pressed
                    if (sessionViewModel.isListening) {  // If the app is listening
                        Log.d("SessionScreen", "Stop Listening button clicked")  // Log that the stop listening button was clicked
                        sessionViewModel.stopListening() // Stop listening
                    } else {
                        Log.d("SessionScreen", "Start Listening button clicked") // Log that the start listening button was clicked
                        sessionViewModel.startListening() // Start listening
                    }
                },
                modifier = Modifier.align(Alignment.CenterHorizontally) // Align the button to the center horizontally
            ) {
                Text(if (sessionViewModel.isListening) "Stop Listening" else "Start Listening")  // Show "Stop Listening" if the app is listening and "Start Listening" if the app is not listening
            }
            Button( // Create a button for the settings button
                onClick = onSettingsClicked, // When the settings button is pressed
                modifier = Modifier.align(Alignment.CenterHorizontally) // Align the button to the center horizontally
            ) {
                Text("Settings") // Show "Settings"
            }
            Button(
                onClick = {
                    scrollToBottomClicked.value = true
                },
                modifier = Modifier.align(Alignment.CenterHorizontally)
            ) {
                Text("Scroll to Bottom")
            }
            Button(
                onClick = { navController.navigate("sessions") },
                modifier = Modifier.align(Alignment.CenterHorizontally)
            ) {
                Text("Saved Conversations")
            }
            Button(
                onClick = { sessionViewModel.saveCurrentConversation() },
                modifier = Modifier.align(Alignment.CenterHorizontally)
            ) {
                Text("Save Conversation")
            }
            Button(
                onClick = {
                    val conversationText = sessionViewModel.conversationMessages.joinToString("\n") { it.message }
                    conversationTextState.value = conversationText
                },
                modifier = Modifier.align(Alignment.CenterHorizontally)
            ) {
                Text("Share Conversation Text")
            }
        }
    }
 
``` 
 
 
```SessionViewModel.kt    
 
package com.example.hello_world.ui.session.viewmodel


class SessionViewModel(
    val conversationId: UUID?,
    val context: Context,
    val settingsViewModel: SettingsViewModel,
    val openAiApiService: OpenAiApiService,
    val conversationRepository: IConversationRepository,
    var textToSpeechServiceState: MutableState<TextToSpeechService>?
) : ViewModel() {


    val latestPartialResult = mutableStateOf<String?>(null)
    val _isAppSpeaking = mutableStateOf(false)
    val mediaPlaybackManager: MediaPlaybackManager = AndroidMediaPlaybackManager()
    private val conversationsManager = ConversationsManager(conversationRepository)
    private val conversationManager = ConversationManager(Conversation(configPack = ConfigPack.defaultConfigPack))
    val isAppSpeaking: Boolean get() = _isAppSpeaking.value
    val showSaveDialog = mutableStateOf(false)
    val saveDialogTitle = mutableStateOf("")

    private val mainHandler = Handler(Looper.getMainLooper())
    val voiceTriggerDetector = VoiceTriggerDetector(context, "Hey", this::onTriggerWordDetected, mainHandler, this.latestPartialResult)

    val conversationMessages = mutableStateListOf<ConversationMessage>().apply {
        addAll(conversationManager.conversation.messages)
    }
    private val _isListening = mutableStateOf(false)
    val isListening: Boolean get() = _isListening.value


    fun loadInitialConversation(conversationId: UUID? = null) {
        viewModelScope.launch {
            val loadedConversation = if (conversationId != null) {
                conversationsManager.loadConversation(conversationId)
            } else {
                null
            }
            if (loadedConversation != null) {
                conversationManager.conversation = loadedConversation
            } else {
                // Use the default profile for the initial conversation
                val initialConversation = Conversation(configPack = ConfigPack.defaultConfigPack)
                conversationManager.conversation = initialConversation
            }
        }
    }


    fun saveCurrentConversation() {
        viewModelScope.launch {
            conversationsManager.saveConversation(conversationManager.conversation)
        }
    }

    fun startListening() {
        voiceTriggerDetector.startListening()
        _isListening.value = true
        Log.d("MainViewModel", "log: from within the startListening() function, `voiceTriggerDetector.startListening()` and `_isListening.value = true` were just called.")
    }
    private suspend fun sendUserMessageToOpenAi(userMessage: String) {


        stopListening()
        val audioFilePathState = mutableStateOf("")
        // Add user message to the conversation state


        val userMessageObj = ConversationMessage("User", userMessage, audioFilePathState)
        conversationManager.addMessage(userMessageObj)
        conversationMessages.add(userMessageObj)


        val responseText = openAiApiService.sendMessage(conversationManager.conversation.messages)
        Log.d("MainViewModel", "Received response from OpenAI API: $responseText")
//        Log.d("MainViewModel", "User message added with audioFilePathState: $audioFilePathState")


        val assistantMessageObj = ConversationMessage("Assistant", responseText, audioFilePathState)
        conversationManager.addMessage(assistantMessageObj)
        conversationMessages.add(assistantMessageObj)

        textToSpeechServiceState?.value?.renderSpeech(responseText.replace("\n", " "), onFinish = {
            if (conversationManager.conversation.messages.isNotEmpty()) {
            mainHandler.post {
                _isAppSpeaking.value = false
                startListening()
                Log.d("MainViewModel", "log: startListening called associated with onFinish")
            }
        }}, onStart = {
            mainHandler.post {
                stopListening()
                Log.d("MainViewModel", "log: stopListening called associated with onStart")
            }
        }, audioFilePathState = conversationManager.conversation.messages.last().audioFilePath)
//        Log.d("MainViewModel", "Updated audioFilePathState: ${audioFilePathState.value}")
        _isAppSpeaking.value = true
    }

    fun updateMessage(index: Int, updatedMessage: ConversationMessage) {
        conversationManager.updateMessage(index, updatedMessage)
        conversationMessages[index] = updatedMessage
    }

    fun deleteMessage(index: Int) {
        viewModelScope.launch {
            conversationManager.deleteMessage(index)
            conversationMessages.removeAt(index)
        }
    }
    private fun startPeriodicListeningCheck() {
        mainHandler.postDelayed({
            if (_isListening.value && _isAppSpeaking.value) {
                Log.d("MainViewModel", "log: Periodic check - Restarting listening")
                startListening()
            }
            startPeriodicListeningCheck()
        }, 3000) // Check every 3 seconds
    }

    fun stopListening() {
        voiceTriggerDetector.stopListening()
        Log.d("MainViewModel", "log: stopListening called 2")
        _isListening.value = false
    }

    fun onTriggerWordDetected(userMessage: String) { // Add userMessage parameter
        // Add user message to the conversation state
        Log.d("MainViewModel", "log: onTriggerWordDetected called")

        // Stop listening
        voiceTriggerDetector.stopListening() // Replace stopListeningForever() with stopListening()
        Log.d("MainViewModel", "log: from within the OnTriggerWordDetected function, `voiceTriggerDetector.stopListening()` was just called")

        // Send the user message to OpenAI API and process the response
        viewModelScope.launch {
            sendUserMessageToOpenAi(userMessage) // Pass the userMessage parameter here
        }
    }

    fun loadConversation(conversationId: UUID) {
        viewModelScope.launch {
            val loadedConversation = conversationsManager.loadConversation(conversationId)
            if (loadedConversation != null) {
                conversationManager.conversation = loadedConversation
                conversationMessages.clear()
                conversationMessages.addAll(conversationManager.conversation.messages)
                Log.d("SessionViewModel", "Loaded conversation ID: ${loadedConversation.id}")
                Log.d("SessionViewModel", "Number of messages in loaded conversation: ${loadedConversation.messages.size}")
                Log.d("SessionViewModel", "Messages in loaded conversation: ${loadedConversation.messages}")
            }
        }
    }
    init {
        loadInitialConversation(conversationId)
        startPeriodicListeningCheck()
    }


    fun saveConversation() {
        showSaveDialog.value = true
    }

    fun onSaveDialogConfirmed() {
        if (saveDialogTitle.value.isNotBlank()) {
            viewModelScope.launch {
                val updatedConversation = conversationManager.conversation.copy(title = saveDialogTitle.value)
                conversationsManager.saveConversation(conversationManager.conversation)
                conversationManager.conversation = updatedConversation
            }
            showSaveDialog.value = false
            saveDialogTitle.value = ""
        }
    }

    fun onSaveDialogDismissed() {
        showSaveDialog.value = false
        saveDialogTitle.value = ""
    }
 
``` 
 
 
```ConfigScreen.kt    
 
package com.example.hello_world


@Composable
fun SettingsScreen(settingsViewModel: SettingsViewModel, onProfileApplied: () -> Unit, navController: NavController) {
    Column(modifier = Modifier.fillMaxSize()) {
        Text("Current Settings", modifier = Modifier.padding(16.dp))
        CurrentSettings(settingsViewModel.selectedConfigPack)

        Spacer(modifier = Modifier.height(16.dp))

        Text("Select a profile", modifier = Modifier.padding(16.dp))

        settingsViewModel.profiles.forEach { profile ->
            Card(
                modifier = Modifier
                    .padding(8.dp)
                    .fillMaxWidth()
                    .clickable { settingsViewModel.applyProfile(profile) }
                    .shadow(elevation = 4.dp) // Add shadow with the 4.dp elevation
            ) {
                Row(
                    modifier = Modifier
                        .padding(16.dp)
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(text = profile.name)
                    Button(onClick = {
                        Log.d("SettingsScreen", "Apply button clicked for profile: $profile")
                        settingsViewModel.applyProfile(profile)
                        onProfileApplied()
                    }) {
                        Text("Apply")
                    }
                    Button(
                        onClick = {
                            Log.d("SettingsScreen", "Edit button clicked for profile: $profile")
                            navController.navigate("edit-settings")
                        }
                    ) {
                        Text("Edit")
                    }
                    if (profile !in settingsViewModel.defaultConfigPacks) {
                        Button(onClick = {
                            Log.d("SettingsScreen", "Delete button clicked for profile: $profile")
                            settingsViewModel.deleteProfile(profile)
                        }) {
                            Text("Delete")
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun CurrentSettings(selectedConfigPack: ConfigPack?) {
    selectedConfigPack?.let { profile ->
        Card(
            modifier = Modifier
                .padding(8.dp)
                .fillMaxWidth()
                .shadow(elevation = 4.dp)
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
            ) {
                Text(text = "Model: ${profile.model}")
                Text(text = "System Message: ${profile.systemMessage}")
                Text(text = "Max Length: ${profile.maxLength}")
                Text(text = "Temperature: ${profile.temperature}")
                Text(text = "Frequency Penalty: ${profile.frequencyPenalty}")
                Text(text = "Presence Penalty: ${profile.presencePenalty}")
            }
        }
    }
 
``` 
 
 
```SettingsViewModel.kt    
 
package com.example.hello_world.ui.settings.viewmodel



class SettingsViewModel : ViewModel() {

    val defaultConfigPacks = listOf(
        ConfigPack("Profile 1", "You are an AI assistant named Jake.", 100, 0.9, 0.0, 0.1, "gpt-3.5-turbo"),
        ConfigPack("Profile 2", "You are an AI assistant named Jane.", 150, 0.8, 0.1, 0.2, "gpt-3.5-turbo")
    )
    val editedConfigPack = mutableStateOf(ConfigPack("", "", 100, 0.9, 0.0, 0.1, "gpt-3.5-turbo"))

    fun updateEditedProfileName(name: String) {
        Log.d("SettingsViewModel", "Profile name updated: $name")
        editedConfigPack.value = editedConfigPack.value.copy(name = name)
    }
    var profiles by mutableStateOf(defaultConfigPacks)
//    var selectedProfile by mutableStateOf<Profile?>(null)
    var selectedConfigPack by mutableStateOf<ConfigPack?>(defaultConfigPacks.first())

    fun saveEditedProfile() {
        if (editedConfigPack.value.name.isNotBlank()) {
            Log.d("SettingsViewModel", "Saving edited profile: ${editedConfigPack.value}")
            saveCustomProfile(editedConfigPack.value)
        }
    }

    fun updateEditedProfileSystemMessage(systemMessage: String) {
        Log.d("SettingsViewModel", "System message updated: $systemMessage")
        editedConfigPack.value = editedConfigPack.value.copy(systemMessage = systemMessage)
    }

    fun updateEditedProfileMaxLength(maxLength: Int) {
        Log.d("SettingsViewModel", "Max length updated: $maxLength")
        editedConfigPack.value = editedConfigPack.value.copy(maxLength = maxLength)
    }

    fun updateEditedProfileTemperature(temperature: Double) {
        Log.d("SettingsViewModel", "Temperature updated: $temperature")
        editedConfigPack.value = editedConfigPack.value.copy(temperature = temperature)
    }

    fun updateEditedProfileFrequencyPenalty(frequencyPenalty: Double) {
        Log.d("SettingsViewModel", "Frequency Penalty updated: $frequencyPenalty")
        editedConfigPack.value = editedConfigPack.value.copy(frequencyPenalty = frequencyPenalty)
    }

    fun updateEditedProfilePresencePenalty(presencePenalty: Double) {
        Log.d("SettingsViewModel", "Presence Penalty updated: $presencePenalty")
        editedConfigPack.value = editedConfigPack.value.copy(presencePenalty = presencePenalty)
    }

    fun updateEditedProfileModel(model: String) {
        Log.d("SettingsViewModel", "Model updated: $model")
        editedConfigPack.value = editedConfigPack.value.copy(model = model)
    }

    fun saveCustomProfile(configPack: ConfigPack) {
        Log.d("SettingsViewModel", "Saving profile: $configPack")
        profiles = profiles.filter { it.name != configPack.name } + configPack
    }


    fun deleteProfile(configPack: ConfigPack) {
        Log.d("SettingsViewModel", "Deleting profile: $configPack")
        profiles = profiles.filter { it != configPack }
    }

    fun applyProfile(configPack: ConfigPack) {
        Log.d("SettingsViewModel", "Applying profile: $configPack")
        selectedConfigPack = configPack
    }
 
``` 
 
 
```Color.kt    
 
package com.example.hello_world.ui.theme


val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
 
``` 
 
 
```Theme.kt    
 
package com.example.hello_world.ui.theme


private val DarkColorScheme = darkColorScheme(
        primary = Purple80,
        secondary = PurpleGrey80,
        tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
        primary = Purple40,
        secondary = PurpleGrey40,
        tertiary = Pink40

        /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun HelloworldTheme(
        darkTheme: Boolean = isSystemInDarkTheme(),
        // Dynamic color is available on Android 12+
        dynamicColor: Boolean = true,
        content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
        }
    }

    MaterialTheme(
            colorScheme = colorScheme,
            typography = Typography,
            content = content
    )
 
``` 
 
 
```Type.kt    
 
package com.example.hello_world.ui.theme


// Set of Material typography styles to start with
val Typography = Typography(
        bodyLarge = TextStyle(
                fontFamily = FontFamily.Default,
                fontWeight = FontWeight.Normal,
                fontSize = 16.sp,
                lineHeight = 24.sp,
                letterSpacing = 0.5.sp
        )
        /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
 
``` 
 
